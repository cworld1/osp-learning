# Mid Exam

## 多道程序设计

- 允许程序并发执行
- 以前不会有虚拟存储的管理，后来有。
- 能够实现共享资源的管理（还会因此产生同步、互斥、死锁）
- 理论上说进程越多，CPU 利用率越高（但是死锁会影响）

## 用户态与内核态执行

- 命令解释程序：把命令以系统能够理解的方式执行（用户态）
- 中断（内核态）
- 进程调度（内核态）
- 时钟中断（内核态）
- 用户态不能执行特权指令

进程启动

- 引导程序处于 ROM 当中，启动会自检
- 不会全部加载系统资源到内存，在需要的时候才会调用
- 启动时也会产生交互

进程：

- 内存不够的时候会被 swap out 到磁盘上

关于系统：

- 不一定提供方 GUI
- 为进程提供系统调用命令
- 操作系统都需要中断进行处理

处理器执行：特权指令、用户指令

- 不允许直接操作特权指令
- 操作系统执行特权指令

cpu 执行 os 代码，处理器处于：内核态

执行系统调用的过程：

- CPU 负责保存断点（就是 PC 指针指向的地址，方便继续执行）和程序状态字（计算机线性状态）
- 操作系统负责保存通用寄存器的内容（用户态转换为内核态）
- 操作系统执行系统调用 routine
- CPU 负责用户态和内核态切换
- 操作系统负责提供中断服务（如 init 等函数）、中断向量表（提供中断处理程序的记录）
- 操作系统保存中断的屏蔽字（指按照优先级处理中断）

进程在内核下有 PCB。

一个进程的状态变化可能会引起另一个进程状态的变化（new 到 ready、waiting/blocked 阻塞到 ready 就不会）

线程与进程

- 线程是比进程更小的单位，但不能独立运行
- 线程能够提高程序的并发性，提高效率

两个合作的进程：

- 通过文件共享
- 通过内存共享
- 通过消息传递共享
- 不能通过全局变量

执行态变柱塞：

- 读取文件：阻塞
- 进程执行完成：就绪
- 申请外设：阻塞
- 进程执行信号量：排队阻塞

旅行社订飞机票，什么属于互斥资源：飞机票，也就是系统的 counter。

初始值 3，当前 1：1 资源可用，0 等待

## 内核态、用户态

区分内核态、用户态：保护程序。

内核态、用户态什么时候切换：中断和中断返回。

为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？

1.  终端型用户。由于终端型用户提交的作业多属于交互性作业，通常较小，系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意。
2.  短批处理作业用户。对于这类作业，如果可在第一队列中执行完成，便可获得与终端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。
3.  长批处理作业用户。对于长作业，它将依次在第 1，2，…，n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。
