import{_ as c,D as i,o as t,c as a,k as e,a as h,I as l,w as s,R as r}from"./chunks/framework.GAJuE5ww.js";const u="/osp-learning/assets/image_1nszh8MIpi.STMDN0L5.png",p="/osp-learning/assets/image_KwDtflAD6C.DMLBuzm0.png",d="/osp-learning/assets/image__0P2200WiE.rILbDg3L.png",m="/osp-learning/assets/image_o6depDZbPq.jhQ1NUK1.png",g="/osp-learning/assets/image_hfcvkNIqh5.ToUPNda7.png",T="/osp-learning/assets/image_RHE_wPna8T.EIjUQItv.png",Q="/osp-learning/assets/image_DHmeVwOCjD.HQHwwjAv.png",f="/osp-learning/assets/image_wH98MvObaI.F8JQ75Sd.png",b="/osp-learning/assets/image_0OXO0NX3xx.YaUGqoeU.png",R=JSON.parse('{"title":"05 CPU Scheduling","description":"","frontmatter":{},"headers":[],"relativePath":"05-cpu-scheduling.md","filePath":"05-cpu-scheduling.md","lastUpdated":1729693534000}'),_={name:"05-cpu-scheduling.md"},P=r('<h1 id="_05-cpu-scheduling" tabindex="-1">05 CPU Scheduling <a class="header-anchor" href="#_05-cpu-scheduling" aria-label="Permalink to &quot;05 CPU Scheduling&quot;">​</a></h1><h2 id="contents" tabindex="-1">Contents <a class="header-anchor" href="#contents" aria-label="Permalink to &quot;Contents&quot;">​</a></h2><ul><li><p>Basic Concepts</p></li><li><p>Scheduling Criteria</p></li><li><p>Scheduling Algorithms</p></li><li><p>Thread Scheduling</p></li><li><p>Multiple-Processor Scheduling</p></li><li><p>Real-Time CPU Scheduling</p></li><li><p>Operating Systems Examples</p></li><li><p>Algorithm Evaluation</p></li></ul><h3 id="objectives" tabindex="-1">Objectives <a class="header-anchor" href="#objectives" aria-label="Permalink to &quot;Objectives&quot;">​</a></h3><ul><li><p>To introduce CPU scheduling, which is the basis for multiprogrammed operating systems</p></li><li><p>To describe various CPU-scheduling algorithms</p></li><li><p>To discuss evaluation criteria for selecting a CPU-scheduling algorithm for a particular system</p></li><li><p>To examine the scheduling algorithms of several operating systems</p></li></ul><h2 id="basic-concepts" tabindex="-1">Basic Concepts <a class="header-anchor" href="#basic-concepts" aria-label="Permalink to &quot;Basic Concepts&quot;">​</a></h2><ul><li><p>Maximum CPU utilization obtained with multiprogramming 多程序运行时 CPU 的最大利用率</p></li><li><p>CPU–I/O Burst Cycle – Process execution consists of a cycle of CPU execution and I/O wait 进程执行由 CPU 执行和 I/O 等待周期组成</p></li><li><p>CPU burst followed by I/O burst CPU 突发后是 I/O 突发</p></li><li><p>CPU burst distribution is of main concern 主要关注 CPU 的突发分布</p></li></ul><h3 id="cpu-scheduler" tabindex="-1">CPU Scheduler <a class="header-anchor" href="#cpu-scheduler" aria-label="Permalink to &quot;CPU Scheduler&quot;">​</a></h3><p>Short-term scheduler selects from among the processes in ready queue, and allocates the CPU to one of them. 短期调度程序从就绪队列中选择进程，并将 CPU 分配给其中一个进程。Queue may be ordered in various ways.</p><p>CPU scheduling decisions(调度策略) may take place when a process:</p><ol><li>Switches from running to waiting state.</li><li>Switches from running to ready state.</li><li>Switches from waiting to ready.</li><li>Terminates.</li></ol><p>Scheduling under 1 and 4 is nonpreemptive(不可中断). All other scheduling is preemptive:</p><ul><li>Consider access to shared data 考虑对共享数据的访问</li><li>Consider preemption while in kernel mode 考虑在内核模式的抢占</li><li>Consider interrupts occurring during crucial OS activities 考虑操作系统关键活动期间发生的中断</li></ul><h3 id="dispatcher" tabindex="-1">Dispatcher <a class="header-anchor" href="#dispatcher" aria-label="Permalink to &quot;Dispatcher&quot;">​</a></h3><p>Dispatcher module gives control of the CPU to the process selected by the short-term scheduler; this involves: 调度模块将 CPU 的控制权交给短期调度程序选择的进程；这包括：</p><ul><li>switching context 切换上下文</li><li>switching to user mode 切换到用户模式</li><li>jumping to the proper location in the user program to restart that program 跳转到用户程序中的适当位置以重新启动该程序</li></ul><h2 id="scheduling-criteria" tabindex="-1">Scheduling Criteria <a class="header-anchor" href="#scheduling-criteria" aria-label="Permalink to &quot;Scheduling Criteria&quot;">​</a></h2><ul><li>CPU utilization – keep the CPU as busy as possible.</li><li>Throughput – # of processes that complete their execution per time unit.</li><li>Turnaround time – amount of time to execute a particular process.</li><li>Waiting time – amount of time a process has been waiting in the ready queue.</li><li>Response time – amount of time it takes from when a request was submitted until the first response is produced, not output (for time-sharing environment).</li></ul><h2 id="scheduling-algorithms" tabindex="-1">Scheduling Algorithms <a class="header-anchor" href="#scheduling-algorithms" aria-label="Permalink to &quot;Scheduling Algorithms&quot;">​</a></h2><h3 id="first-come-first-served-fcfs-scheduling" tabindex="-1">First-Come, First-Served (FCFS) Scheduling <a class="header-anchor" href="#first-come-first-served-fcfs-scheduling" aria-label="Permalink to &quot;First-Come, First-Served (FCFS) Scheduling&quot;">​</a></h3><p>Example:</p><p><img src="'+u+'" alt=""></p><p>Suppose that the processes arrive in the order: P1, P2, P3</p><p>The Gantt Chart for the schedule is 进度表的甘特图为:</p><p><img src="'+p+'" alt=""></p><p>非抢占式。</p>',26),x={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"20.49ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 9056.4 1000","aria-hidden":"true"},C=e("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[e("g",{"data-mml-node":"math"},[e("g",{"data-mml-node":"mo"},[e("path",{"data-c":"28",d:"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mn",transform:"translate(389,0)"},[e("path",{"data-c":"30",d:"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mo",transform:"translate(1111.2,0)"},[e("path",{"data-c":"2B",d:"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mn",transform:"translate(2111.4,0)"},[e("path",{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z",style:{"stroke-width":"3"}}),e("path",{"data-c":"34",d:"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z",transform:"translate(500,0)",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mo",transform:"translate(3333.7,0)"},[e("path",{"data-c":"2B",d:"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mn",transform:"translate(4333.9,0)"},[e("path",{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z",style:{"stroke-width":"3"}}),e("path",{"data-c":"37",d:"M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z",transform:"translate(500,0)",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mo",transform:"translate(5333.9,0)"},[e("path",{"data-c":"29",d:"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"TeXAtom","data-mjx-texclass":"ORD",transform:"translate(5722.9,0)"},[e("g",{"data-mml-node":"mo"},[e("path",{"data-c":"2F",d:"M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z",style:{"stroke-width":"3"}})])]),e("g",{"data-mml-node":"mn",transform:"translate(6222.9,0)"},[e("path",{"data-c":"33",d:"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mo",transform:"translate(7000.7,0)"},[e("path",{"data-c":"3D",d:"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z",style:{"stroke-width":"3"}})]),e("g",{"data-mml-node":"mn",transform:"translate(8056.4,0)"},[e("path",{"data-c":"31",d:"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z",style:{"stroke-width":"3"}}),e("path",{"data-c":"37",d:"M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z",transform:"translate(500,0)",style:{"stroke-width":"3"}})])])],-1),S=[C],w=e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mo",{stretchy:"false"},"("),e("mn",null,"0"),e("mo",null,"+"),e("mn",null,"24"),e("mo",null,"+"),e("mn",null,"27"),e("mo",{stretchy:"false"},")"),e("mrow",{"data-mjx-texclass":"ORD"},[e("mo",null,"/")]),e("mn",null,"3"),e("mo",null,"="),e("mn",null,"17")],-1),q=r('<h3 id="shortest-job-first-sjf-scheduling" tabindex="-1">Shortest-Job-First (SJF) Scheduling <a class="header-anchor" href="#shortest-job-first-sjf-scheduling" aria-label="Permalink to &quot;Shortest-Job-First (SJF) Scheduling&quot;">​</a></h3><p>Example:</p><p><img src="'+d+'" alt=""></p><p>SJF scheduling chart:</p><p><img src="'+m+'" alt=""></p><p>一般是非抢占式。但如果分时间片就可能变成抢占式。</p><h3 id="round-robin-rr-scheduling" tabindex="-1">Round Robin (RR) Scheduling <a class="header-anchor" href="#round-robin-rr-scheduling" aria-label="Permalink to &quot;Round Robin (RR) Scheduling&quot;">​</a></h3><p>即为轮转调度。</p><p>Example with Time Quantum = 4:</p><p><img src="'+g+'" alt=""></p><p>Gantt chart:</p><p><img src="'+T+'" alt=""></p><h2 id="thread-scheduling" tabindex="-1">Thread Scheduling <a class="header-anchor" href="#thread-scheduling" aria-label="Permalink to &quot;Thread Scheduling&quot;">​</a></h2><h3 id="multilevel-queue" tabindex="-1">Multilevel Queue <a class="header-anchor" href="#multilevel-queue" aria-label="Permalink to &quot;Multilevel Queue&quot;">​</a></h3><p>Ready queue is partitioned into separate queues 就绪队列被分割成不同的队列, e.g.:</p><ul><li><p>foreground (interactive)</p></li><li><p>background (batch)</p></li></ul><p>Process permanently in a given queue 永久处理指定队列</p><p>Each queue has its own scheduling algorithm 每个队列都有自己的调度算法:</p><ul><li><p>foreground – RR</p></li><li><p>background – FCFS</p></li></ul><p>Scheduling must be done between the queues:</p><ul><li><p>Fixed priority scheduling; (i.e., serve all from foreground then from background). Possibility of starvation.</p><p>固定优先级调度（即先从前台再从后台提供服务）。 可能出现饥饿。</p></li><li><p>Time slice – each queue gets a certain amount of CPU time which it can schedule amongst its processes;</p><p>时间片-每个队列获得一定量的 CPU 时间，它可以在其进程之间调度</p><p>i.e., 80% to foreground in RR, 20% to background in FCFS</p></li></ul><h3 id="multilevel-queue-scheduling" tabindex="-1">Multilevel Queue Scheduling <a class="header-anchor" href="#multilevel-queue-scheduling" aria-label="Permalink to &quot;Multilevel Queue Scheduling&quot;">​</a></h3><p><img src="'+Q+'" alt=""></p><h3 id="multilevel-feedback-queue" tabindex="-1">Multilevel Feedback Queue <a class="header-anchor" href="#multilevel-feedback-queue" aria-label="Permalink to &quot;Multilevel Feedback Queue&quot;">​</a></h3><p>过程可以在各个队列之间移动，可以使用老化的方法来实现老化（aging can be implemented this way）。</p><p>多级反馈队列调度器定义如下参数：</p><ul><li><p>队列的数量</p></li><li><p>每个队列的调度算法</p></li><li><p>确定何时升级进程的方法</p></li><li><p>确定何时降级进程的方法</p></li><li><p>确定当需要服务时，进程将进入哪个队列的方法</p></li></ul><p>用户级线程和内核级线程之间的区别：</p><ul><li><p>当支持线程时，调度的是线程，而不是进程</p></li><li><p>多对一和多对多模型，线程库调度用户级线程在 LWP 上运行</p><p>被称为进程保留范围（PCS），因为调度竞争是在进程内部进行的 </p><p>通常通过程序员设置的优先级来完成</p></li><li><p>调度到可用 CPU 上的内核线程是系统保留范围（SCS） - 系统中所有线程之间的竞争</p></li></ul><h2 id="multiple-processor-scheduling" tabindex="-1">Multiple-Processor Scheduling <a class="header-anchor" href="#multiple-processor-scheduling" aria-label="Permalink to &quot;Multiple-Processor Scheduling&quot;">​</a></h2><ul><li>CPU 调度在多 CPU 环境下更为复杂</li><li>Homogeneous processors within a multiprocessor 多处理器中的同构处理器</li><li>Asymmetric multiprocessing 非对称多处理器（只有一个处理器访问系统数据结构，缓解了数据共享的需求）</li><li>Symmetric multiprocessing 对称多处理器（SMP）——每个处理器都是自我调度的，共享数据队列或每个处理器都有自己的准备好的进程队列（目前，大多数通用情况都是这个）</li><li>进程绑定——进程对正在运行的处理器具有绑定 <ul><li>软绑定</li><li>硬绑定</li><li>包括处理器集合等变体</li></ul></li></ul><h3 id="multicore-processors" tabindex="-1">Multicore Processors <a class="header-anchor" href="#multicore-processors" aria-label="Permalink to &quot;Multicore Processors&quot;">​</a></h3><p>将多个处理器内核置于同一物理芯片的最新趋势：</p><ul><li>速度更快，功耗更低</li><li>每个内核的多个线程数量也在增加（利用内存滞留，在内存检索时在另一个线程上取得进展）</li></ul><h2 id="real-time-cpu-scheduling" tabindex="-1">Real-Time CPU Scheduling <a class="header-anchor" href="#real-time-cpu-scheduling" aria-label="Permalink to &quot;Real-Time CPU Scheduling&quot;">​</a></h2><p>可能会带来明显的挑战：</p><ul><li>软实时系统 – 无法保证何时安排关键的实时过程</li><li>硬实时系统 – 任务必须在截止日期前提供服务</li></ul><p>两种类型的延迟会影响性能：</p><ul><li>中断延迟 – 从中断到达到服务中断的例程开始的时间</li><li>调度延迟 – 计划将当前进程从 CPU 中取出并切换到另一个进程的时间</li></ul><p><img src="'+f+'" alt=""></p><h2 id="operating-systems-examples" tabindex="-1">Operating Systems Examples <a class="header-anchor" href="#operating-systems-examples" aria-label="Permalink to &quot;Operating Systems Examples&quot;">​</a></h2><p>Linux Scheduling:</p><ul><li>Real-time scheduling according to POSIX.1b (Real-time tasks have static priorities 实时任务具有静态优先级)</li><li>Real-time plus normal map into global priority scheme 实时加法线映射到全局优先级计划中</li><li>Nice value of -20 maps to global priority 100（实时进程）</li><li>Nice value of +19 maps to priority 139（一般进程）</li></ul><h2 id="algorithm-evaluation" tabindex="-1">Algorithm Evaluation <a class="header-anchor" href="#algorithm-evaluation" aria-label="Permalink to &quot;Algorithm Evaluation&quot;">​</a></h2><p>How to select CPU-scheduling algorithm for an OS?</p><ul><li>Determine criteria, then evaluate algorithms 确定标准，然后评估算法</li><li>Deterministic modeling 确定性建模</li><li>Type of analytic evaluation 分析评估的类型</li><li>Takes a particular predetermined workload and defines the performance of each algorithm for that workload 采用特定的预定工作负载，并定义该工作</li></ul><h2 id="extra" tabindex="-1">Extra <a class="header-anchor" href="#extra" aria-label="Permalink to &quot;Extra&quot;">​</a></h2><h3 id="线程与传统进程的比较" tabindex="-1">线程与传统进程的比较 <a class="header-anchor" href="#线程与传统进程的比较" aria-label="Permalink to &quot;线程与传统进程的比较&quot;">​</a></h3><p>线程具有许多传统进程所拥有的特性，因此有人将它称为轻量级进程，而将传统进程称为重量级进程。线程与传统进程相比则有不少相似之处。</p><ol><li>二者都有标识符（ID）、一组寄存器、状态、优先级及所要遵循的调度策略。</li><li>进程有一个进程控制块（PCB），线程也有一个线程控制块（TCB）。</li><li>进程中的线程共享该进程的资源，子进程也共享父进程的资源，线程和子进程的创建者可以对线程和子进程实施某些控制。如创建者可以撤销、挂起、激活被创建者，以及修改被创建者的优先级，线程和子进程可以改变其属性并创建新的线程和子进程。</li></ol><p>传统进程不涉及线程概念，它由进程控制块、程序和数据空间、用户栈和核心栈等组成。在具有多线程结构的进程中，尽管进程仍然具有进程控制块和与本进程关联的程序和数据空间，但每个线程有各自独立的线程控制块、用户栈和核心栈以及线程状态信息。具有多线程结构的进程模型和传统进程的模型如图 2-18 所示。</p><p><img src="'+b+'" alt="图2-18　传统进程和具有多线程的进程结构示意" title="图2-18　传统进程和具有多线程的进程结构示意"></p><p>线程与传统进程主要存在以下 5 个差异。</p><ol><li>传统进程除是调度和分派的基本单位外，还是资源分配的基本单位。而在引入线程的操作系统中，线程只是调度和分派的基本单位。</li><li>在引入线程的系统中，不仅同一个进程中的多个线程可以并发执行，而且属于不同进程中的多个线程也可以并发执行（也称为进程并发执行），线程并发执行的程度高于传统进程并发执行的程度。</li><li>创建和撤销一个线程所花费的时空开销远小于创建和撤销一个传统进程所花费的时空开销。尤其是线程间彼此切换所需的时间远少于传统进程间切换所需要的时间。</li><li>传统进程是系统资源分配的基本单位，而线程基本不拥有资源，但可以使用它所隶属进程的资源，如程序段、数据段、打开的文件及 I/O 设备等。不同进程的地址空间是相互独立的，而属于同一个进程的所有线程共享同一个地址空间（该进程的地址空间）。</li><li>由于不同进程具有各自独立的数据空间，因此要进行数据传递只能通过通信方式进行，这种方式相对费时而且不方便。但在多线程操作系统中，一个进程的数据空间被该进程的所有线程所共享，一个线程的数据可以直接被属于同一个进程的其他线程所使用，因此数据传递既方便又快捷。</li></ol><h3 id="线程实现" tabindex="-1">线程实现 <a class="header-anchor" href="#线程实现" aria-label="Permalink to &quot;线程实现&quot;">​</a></h3><p>进程在 CPU 上实现并发，而 CPU 由操作系统管理。因此进程的实现只能由操作系统内核来进行。但线程就不同了，因为线程隶属进程，除操作系统可以管理线程外，当然也可以由进程直接管理线程。因此线程存在着内核态与用户态两种实现方法。</p><ol><li>内核态线程实现。</li><li>用户态线程实现。</li><li>混合式线程实现。</li></ol>',57);function v(k,H,y,V,U,M){const o=i("mjx-assistive-mml"),n=i("mjx-container");return t(),a("div",null,[P,e("p",null,[h("Average waiting time: "),l(n,{class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},{default:s(()=>[(t(),a("svg",x,S)),l(o,{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},{default:s(()=>[w]),_:1})]),_:1})]),q])}const F=c(_,[["render",v]]);export{R as __pageData,F as default};
