import{_ as a,o as e,c as p,R as i}from"./chunks/framework.GAJuE5ww.js";const E=JSON.parse('{"title":"什么是临界资源，临界区？","description":"","frontmatter":{},"headers":[],"relativePath":"ex-critical-res.md","filePath":"ex-critical-res.md","lastUpdated":1729693534000}'),r={name:"ex-critical-res.md"},t=i(`<h1 id="什么是临界资源-临界区" tabindex="-1">什么是临界资源，临界区？ <a class="header-anchor" href="#什么是临界资源-临界区" aria-label="Permalink to &quot;什么是临界资源，临界区？&quot;">​</a></h1><p><a href="https://www.zhihu.com/question/379849079" target="_blank" rel="noreferrer">https://www.zhihu.com/question/379849079</a></p><h2 id="什么是临界区" tabindex="-1">什么是临界区？ <a class="header-anchor" href="#什么是临界区" aria-label="Permalink to &quot;什么是临界区？&quot;">​</a></h2><p>每个进程中访问临界资源的那段程序称为临界区（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。</p><h2 id="进程进入临界区的调度原则" tabindex="-1">进程进入临界区的调度原则 <a class="header-anchor" href="#进程进入临界区的调度原则" aria-label="Permalink to &quot;进程进入临界区的调度原则&quot;">​</a></h2><ol><li>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</li><li>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>如果进程不能进入自己的临界区，则应让出 CPU，避免进程出现“忙等”现象。</li></ol><p>互斥对象是一种最简单的内核对象，用它可以方便的实现对某一资源的互斥访问。因为它是内核对象，因此可以产生信号，实际上，程序中就是利用这一点实现互斥的。如果没记错的话，临界区并不是内核对象，而是系统提供的一种数据结构，程序中可以声明一个该类型变量，之后用它来实现对资源的互斥访问。当欲访问某一临界资源时，先将该临界区加锁（如果临界区不空闲，等待），用完该资源后，将临界区释放。一般，将他们用于线程间的同步，而且通常可以互换使用。如果要实现复杂互斥，应使用其它方法，如信号量内核对象等。临界区对象不能跨越进程，是线程间共享数据区的同步对象；互斥对象可以作为进程间共享数据区的同步对象。</p><p>下面着重讲解进程管理（实现临界区互斥的方法）。</p><h2 id="访问临界资源" tabindex="-1">访问临界资源 <a class="header-anchor" href="#访问临界资源" aria-label="Permalink to &quot;访问临界资源&quot;">​</a></h2><p>对临界资源的访问分为四个部分：</p><ol><li>进入区：检查是否可以进入临界区,若可以则设置正在访问临界区的标志(加锁),以阻止其他进程同时进入临界区</li><li>临界区：进程中访问临界资源的那段代码</li><li>退出区：解除正在访问临界资源的标志(解锁)</li><li>剩余区：处理代码的其余部分<div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  enter section;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //进入区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  critical section;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //临界区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  exit section;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //退出区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  remainder section;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //剩余区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li></ol><h2 id="实现临界区互斥的方法" tabindex="-1">实现临界区互斥的方法 <a class="header-anchor" href="#实现临界区互斥的方法" aria-label="Permalink to &quot;实现临界区互斥的方法&quot;">​</a></h2><p><em>同步机制应当遵循的准则:</em></p><ol><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待：当已经有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待：对请求访问临界区的进程，应保证其在有限的时间内进入临界区</li><li><a href="https://www.zhihu.com/search?q=%E8%AE%A9%E6%9D%83%E7%AD%89%E5%BE%85&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="让权等待" target="_blank" rel="noreferrer">让权等待</a>：当进程不能进入临界区时，应立即释放处理机</li></ol><h4 id="_1-通过软件实现" tabindex="-1">1. 通过软件实现 <a class="header-anchor" href="#_1-通过软件实现" aria-label="Permalink to &quot;1. 通过软件实现&quot;">​</a></h4><p>软件方法相对复杂且容易出错,因而现在系统较少采用,目前常用的方法是通过硬件方法实现同步互斥操作</p><h4 id="_1-单标志法" tabindex="-1">(1)单标志法 <a class="header-anchor" href="#_1-单标志法" aria-label="Permalink to &quot;(1)单标志法&quot;">​</a></h4><p>特征:(设置标志 turn)</p><ol><li><p>设置 turn 来标志当前允许运行的<a href="https://www.zhihu.com/search?q=%E8%BF%9B%E7%A8%8B%E7%BC%96%E5%8F%B7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="进程编号" target="_blank" rel="noreferrer">进程编号</a></p></li><li><p>每个进程访问完临界区后把临界区的使用权转交给另一个进程</p></li><li><p>若<a href="https://www.zhihu.com/search?q=turn&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="turn" target="_blank" rel="noreferrer">turn</a>的初始值为 0,则运行进程始终按照 p0-&gt;p1-&gt;p0-&gt;p1-&gt;…的顺序进行,如果其中的某个进程不再进入临界区则另一个进程也将无法进入临界区. 违背了&quot;<a href="https://www.zhihu.com/search?q=%E7%A9%BA%E9%97%B2%E8%AE%A9%E8%BF%9B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="空闲让进" target="_blank" rel="noreferrer">空闲让进</a>&quot;的原则</p><p>turn=0;</p><p>/**</p><p>P0 进程</p><p>**/</p><p>while(turn!=0); //进入区</p><p>critical section; //临界区</p><p>turn = 1; //退出区</p><p>remainder section; //剩余区</p><p>/**</p><p>P1 进程</p><p>**/</p><p>while(turn!=1);</p><p>//turn 初始值为 0,若先进去的是 p1 进程则,</p><p>//while 循环条件成立,处理机一直进行空循环,</p><p>//直到分配给进程的的时间片结束</p><p>critical section;</p><p>turn = 0;</p><p>remainder section;</p></li></ol><h4 id="_2-双标志法先检查" tabindex="-1">(2)<a href="https://www.zhihu.com/search?q=%E5%8F%8C%E6%A0%87%E5%BF%97%E6%B3%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="双标志法" target="_blank" rel="noreferrer">双标志法</a>先检查 <a class="header-anchor" href="#_2-双标志法先检查" aria-label="Permalink to &quot;(2)[双标志法](https://www.zhihu.com/search?q=双标志法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;:&quot;answer&quot;,&quot;sourceId&quot;:2761131448} &quot;双标志法&quot;)先检查&quot;">​</a></h4><p>特征:(设置 flag[]标志对方和自己)</p><ol><li><p>设置标志 flag[i]来标志各个进程进入临界区的意愿</p></li><li><p>刚开始时先把 flag[i]中各个元素的值设置成 false</p></li><li><p>如果 flag[i]的值为 FALSE 则表示 pi 进程未进入临界区,如果值为 TRUE,表示 Pi 进程进入临界区</p></li><li><p>优点:不用按照一定顺序交替进入临界区,可以连续使用</p></li><li><p>缺点:由于操作系统的并发性,如果 pi 和 pj 进程同时进入临界区,则可能按照 ①②③③ 的顺序执行,则导致两个进程同时进入了临界区,违背了&quot;忙则等待&quot;的原则</p><p>/**</p><p>pi 进程:</p><p>当 pi 进程想要访问临界资源时,首先判断 flag[j]是否为 TRUE:</p><ol><li>如果为 TRUE,说明 pj 进程处于临界区(在访问临界资源),则 pi 进程进行空循环, 直到处理机分配给 pi 的时间片结束发生进程切换,使得 pi 进程退出处理机</li><li>如果为 FALSE,则说明 pj 进程不在临界区中(没有在访问临界资源),则将 flag[i] 设置成 TRUE,以阻止其他进程来访问临界区(上锁),由此进入区完成</li></ol><p>**/</p><p>while(flag[j]); ① //进入区</p><p>flag[i] = TRUE; ③ //进入区</p><p>critical section; //临界区</p><p>flag[i] = false; //退出区</p><p>remainder section; //剩余区</p><p>/**</p><p>pj 进程:</p><p>**/</p><p>while(flag[i]); ②</p><p>flag[j] = TRUE; ③</p><p>critical section;</p><p>flag[j] = false;</p><p>remainder section;</p></li></ol><p><em>由上可以看出软件方法都会导致进程等待进入临界区时由于空循环造成的浪费处理机时间的现象，违背了“让权等待”</em></p><h4 id="_3-双标志法后检查" tabindex="-1">(3)双标志法后检查 <a class="header-anchor" href="#_3-双标志法后检查" aria-label="Permalink to &quot;(3)双标志法后检查&quot;">​</a></h4><p>特征:</p><ol><li><p>设置 flag[]来标志各个进程访问临界区的意愿</p></li><li><p>先将自己的 flag[]标志设置成 TRUE,再检查对方进程的标志,若对方标志为 TRUE,则进程等待,否则进入临界</p></li><li><p>若 pi 和 pj 进程几乎同时进入临界区时,由于并发性,可能将自己的 flag 都设置成 TRUE,导致两个进程都只能处于等待状态,从而导致&quot;饥饿&quot;现象,违背了有限等待的原则</p><p>/**</p><p>pi 进程:</p><p>**/</p><p>flag[i] = TRUE; //进入区</p><p>while(flag[j]); //进入区</p><p>critical section; //临界区</p><p>flag[i] = false; //退出区</p><p>remainder section; //剩余区</p><p>/**</p><p>pj 进程:</p><p>**/</p><p>flag[j] = TRUE;</p><p>while(flag[i]);</p><p>critical section;</p><p>flag[j] = false;</p><p>remainder section;</p></li></ol><h4 id="_4-peterson-s-algorithm" tabindex="-1">(4)Peterson’s Algorithm <a class="header-anchor" href="#_4-peterson-s-algorithm" aria-label="Permalink to &quot;(4)Peterson’s Algorithm&quot;">​</a></h4><p>特点:(三标志,除了 flag[]标志意愿之外还有<a href="https://www.zhihu.com/search?q=turn%E6%A0%87%E5%BF%97&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="turn标志" target="_blank" rel="noreferrer">turn 标志</a>)</p><ol><li><p>为了防止进程为进入临界区而出现的无限等待的情况,在双标志法后检查的基础上增添了 turn 标志表示意愿把进入临界区的权限让给另外一个进程</p><p>/**</p><p>pi 进程:</p><p>首先将自己的 flag 标志设置成 True(加锁,加锁后如果 pj 想进入临界区则会进入空循环中),</p><p>将不允许进入的程序标志 turn 设置成 j,如果出现了两个进程几乎同时想要访问临界区的情况时,</p><p>在 pi 和 pj 将自己的意愿都设置成 true 之后,由于 turn 的值唯一,所以优先让一个进程进入了临界区,</p><p>另一个进程则处于空循环等待前一个进程退出临界区，解决了&quot;无限等待&quot;的问题</p><p>**/</p><p>flag[i] = TRUE; //进入区</p><p>turn = j; //进入区</p><p>while(flag[j] &amp;&amp; turn ==j); //进入区</p><p>critical section; //临界区</p><p>flag[i] = false; //退出区</p><p>remainder section; //剩余区</p><p>/**</p><p>pj 进程:</p><p>**/</p><p>flag[j] = TRUE;</p><p>turn = i;</p><p>while(flag[i] &amp;&amp; turn ==i);</p><p>critical section;</p><p>flag[j] = false;</p><p>remainder section;</p></li></ol><h4 id="_2-硬件实现方法" tabindex="-1">2. 硬件实现方法 <a class="header-anchor" href="#_2-硬件实现方法" aria-label="Permalink to &quot;2. 硬件实现方法&quot;">​</a></h4><p>也称低级方法或原方法</p><h4 id="_1-中断屏蔽方法" tabindex="-1">(1)中断屏蔽方法 <a class="header-anchor" href="#_1-中断屏蔽方法" aria-label="Permalink to &quot;(1)中断屏蔽方法&quot;">​</a></h4><ol><li>由于 CPU 只在发生中断时引起进程切换,因此屏蔽中断可保证当前进程让<a href="https://www.zhihu.com/search?q=%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="临界区代码" target="_blank" rel="noreferrer">临界区代码</a>顺利执行完</li><li>缺点:限制了处理机交替执行程序的能力,因此执行效率会明显降低,同时将<a href="https://www.zhihu.com/search?q=%E5%85%B3%E4%B8%AD%E6%96%AD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="关中断" target="_blank" rel="noreferrer">关中断</a>的权利交给用户是十分危险的,如果一个进程关中断之后不再打开则会导致系统终止</li></ol><p>典型模式:</p><p>/**</p><p>关中断</p><p>临界区</p><p>开中断</p><p>**/</p><h4 id="_2-硬件指令方法" tabindex="-1">(2)硬件指令方法 <a class="header-anchor" href="#_2-硬件指令方法" aria-label="Permalink to &quot;(2)硬件指令方法&quot;">​</a></h4><h4 id="i-testandset-指令" tabindex="-1">i.TestAndSet 指令 <a class="header-anchor" href="#i-testandset-指令" aria-label="Permalink to &quot;i.TestAndSet 指令&quot;">​</a></h4><ol><li><p>这是一条<a href="https://www.zhihu.com/search?q=%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2761131448%7D" title="原子操作" target="_blank" rel="noreferrer">原子操作</a>（执行改代码时不允许被中断）</p></li><li><p>读出指定标志之后把该标志设置成真</p><p>/**</p><p>TestAndSet:</p><p>lock 用于表示临界资源的两种状态：true 表示正被占用，初值为 false</p><p>**/</p><p>boolean TestAndSet(boolean *lock){</p><p>boolean old;</p><p>old = *lock; //用 old 记录指定标志</p><p>*lock = true; //读出指定标志之后把标志 lock 设置成真</p><p>return old;</p><p>}</p><p>/**</p><p>实现进程访问临界区的代码：</p><p>在进入临界区之前先用 TestAndSet 来检查 lock 和修改 lock；若 lock 为 false</p><p>说明临界资源没有被占用，则可以进入临界区，并把临界资源的占用情况设置成 true（给临界资源上锁）。</p><p>如果 lock 为 true 则说明临界资源正被占用，则进程只能进行空循环直到处理机分配的时间片结束，进程退出。</p><p>**/</p><p>while TestAndSet(&amp;lock); //进入区</p><p>进程的其他代码段 //临界区</p><p>lock = false; //退出区</p><p>进程的其他代码; //剩余区</p></li></ol><h4 id="ii-swap-指令" tabindex="-1">ii.Swap 指令 <a class="header-anchor" href="#ii-swap-指令" aria-label="Permalink to &quot;ii.Swap 指令&quot;">​</a></h4><ol><li><p>Swap 指令用于交换两个字节的内容</p><p>/**</p><p>Swap 指令：</p><p>**/</p><p>Swap(boolean *a,boolean *b){</p><p>boolean temp;</p><p>temp = *a;</p><p>*a = *b;</p><p>*b = temp; </p><p>}</p><p>/**</p><p>进程访问临界区处理：</p><p>lock 用于表示临界资源是否被占用，true 表示被占用</p><p>设置 key 用于与 lock 交换信息。在进入临界区之前先用 key 交换信息，如果交换后 key 仍为 true，</p><p>说明临界资源已被占用，则接下来持续进行检查 key 和交换的过程，直到时间片结束</p><p>**/</p><p>key = true; //进入区</p><p>while(key!= false)</p><p>Swap(&amp;lock，&amp;key); //进入区</p><p>进程的临界区代码段； //临界区</p><p>lock =false; //退出区</p><p>进程的其他代码; //剩余区</p></li><li><p>硬件方法的优点：适用于任意数目的进程，不管是单处理机还是多处理机。同时也支持进程中有多个临界区，只要为每个临界区都设置一个 boolean 变量就行。</p></li><li><p>缺点：进程在等待进入临界区的时候，处理机只能处于一个空循环的状态，这样的状态浪费处理机资源，违背了“让权等待”，从进程中随机选择一个进程进入临界区，有的进程就可能一直都选不上，导致饥饿现象，违背”有限等待“。</p></li></ol>`,44),l=[t];function s(o,h,n,c,u,d){return e(),p("div",null,l)}const m=a(r,[["render",s]]);export{E as __pageData,m as default};
