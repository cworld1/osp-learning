import{_ as a,o as e,c as i,R as r}from"./chunks/framework.GAJuE5ww.js";const l="/osp-learning/assets/image_EjdTGrOj36.jCXiuJd2.png",b=JSON.parse('{"title":"12 I/O System","description":"","frontmatter":{},"headers":[],"relativePath":"12-io-sys.md","filePath":"12-io-sys.md","lastUpdated":1729693534000}'),t={name:"12-io-sys.md"},o=r('<h1 id="_12-i-o-system" tabindex="-1">12 I/O System <a class="header-anchor" href="#_12-i-o-system" aria-label="Permalink to &quot;12 I/O System&quot;">​</a></h1><h2 id="contents" tabindex="-1">Contents <a class="header-anchor" href="#contents" aria-label="Permalink to &quot;Contents&quot;">​</a></h2><ul><li>Overview</li><li>I/O Hardware</li><li>Application I/O Interface</li><li>Kernel I/O Subsystem</li><li>Transforming I/O Requests to Hardware Operations</li><li>STREAMS</li><li>Performance</li></ul><h3 id="objectives" tabindex="-1">Objectives <a class="header-anchor" href="#objectives" aria-label="Permalink to &quot;Objectives&quot;">​</a></h3><ul><li>Explore the structure of an operating system’s I/O subsystem </li><li>Discuss the principles of I/O hardware and its complexity </li><li>Provide details of the performance aspects of I/O hardware and software</li></ul><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>对与计算机相连设备的控制是操作系统设计者的主要任务之一。因为 I/O 设备在其功能与速度方面存在很大的差异，所以需要采用多种方法来控制设备。这些方法形成了 I/O 子系统的核心，该子系统使内核其他部分不必涉及复杂的 I/O 设备管理。</p><p>I/O 设备技术呈现两个相矛盾的趋势：</p><ul><li><p>一方面，可以看到硬件与软件接口日益增长的标准化。这一趋势有助于将设备集成到现有计算机和操作系统。</p></li><li><p>另一方面，也可以看到 I/O 设备日益增长的多样性。有的新设备与以前的设备区别很大，以至于很难集成到计算机和操作系统中，这种困难需要运用软件技术和硬件技术一起来解决。</p></li></ul><p>一般的解决方法：</p><ul><li>I/O 设备的基本要素如端口、总线和设备控制器适用于许多不同的 I/O 设备。为了封装不同设备的细节和特点，操作系统内核设计成使用设备驱动程序模块的结构。设备驱动程序为 I/O 子系统提供了统一设备访问接口，就像系统调用为应用程序和操作系统之间提供了统一的标准接口一样。</li></ul><h2 id="i-o-hardware" tabindex="-1">I/O Hardware <a class="header-anchor" href="#i-o-hardware" aria-label="Permalink to &quot;I/O Hardware&quot;">​</a></h2><p>总线： 是一组线和一组严格定义的可以描述在线上传输信息的协议。</p><p>控制器： 是用于操作端口、总线或设备的一组电子器件。</p><p>处理器如何向控制器发送命令和数据以完成 I/O 传输？</p><ul><li><p>控制器可以有一个或多个用于数据和控制信号寄存器。处理器通过读写这些寄存器的位模式来与控制器通信。这种通信的一种方法是通过使用特殊 I/O 指令来向指定的 I/O 端口地址传输一个字节或字。</p></li><li><p>设备控制器也可支持内存映射 I/O。这时，设备控制寄存器被映射到处理器的地址空间。处理器执行 I/O 请求是通过标准数据传输指令来完成对设备控制器的读写。</p></li></ul><p>I/O 端口通常有四种寄存器：</p><ul><li><p>状态寄存器： 包含一些主机可以读取的位(bit)。这些位指示各种状态，例如，当前任务是否完成，数据输入寄存器是否有数据可以读取，是否出现设备故障等。</p></li><li><p>控制寄存器： 可以被主机用来向设备发送命令或改变设备状态。</p></li><li><p>数据输入寄存器： 被主机读出以获取数据。</p></li><li><p>数据输出寄存器： 被主机写入以发送数据。</p></li></ul><blockquote><p>下面都是讲主机如何与 I/O 进行交互的协议或硬件支持</p></blockquote><h3 id="轮询" tabindex="-1">轮询 <a class="header-anchor" href="#轮询" aria-label="Permalink to &quot;轮询&quot;">​</a></h3><p>控制器有 1bit 来显示其状态，主机的命令寄存器有 1bit 就绪位来显示其状态。控制器工作忙时就置忙位，而可以接收下一命令时就清忙位。主机通过命令寄存器中命令就绪位来表示其意愿。当主机有命令需要控制器执行时，就置命令就绪位。</p><p>具体握手协议如下：</p><ol><li><p>主机不断地读取忙位，直到该位被清除。</p></li><li><p>主机设置命令寄存器中的写位并向数据输出寄存器中写入一个字节。</p></li><li><p>主机设置命令就绪位。</p></li><li><p>当控制器注意到命令就绪位以被设置，则设置忙位。</p></li><li><p>控制器读取命令寄存器，并看到写命令。它从数据输出寄存器中读取一个字节，并向设备执行 I/O 操作。</p></li><li><p>在步骤 1 中，主机处于忙等待或轮询。</p></li></ol><h3 id="中断" tabindex="-1">中断 <a class="header-anchor" href="#中断" aria-label="Permalink to &quot;中断&quot;">​</a></h3><p>中断在第一章提到过。</p><h3 id="直接内存访问-dma" tabindex="-1">直接内存访问(DMA) <a class="header-anchor" href="#直接内存访问-dma" aria-label="Permalink to &quot;直接内存访问(DMA)&quot;">​</a></h3><p>DMA 需要硬件支持，称为直接内存访问(direct-memory access)控制器。</p><p>DMA 具体传输步骤 Six Step Process to Perform DMA Transfer：</p><p><img src="'+l+'" alt=""></p><h2 id="application-i-o-interface" tabindex="-1">Application I/O Interface <a class="header-anchor" href="#application-i-o-interface" aria-label="Permalink to &quot;Application I/O Interface&quot;">​</a></h2><h3 id="块与字符设备" tabindex="-1">块与字符设备 <a class="header-anchor" href="#块与字符设备" aria-label="Permalink to &quot;块与字符设备&quot;">​</a></h3><p>块设备：</p><ul><li><p>命令包括 read, write, seek。</p></li><li><p>访问方式包括生 I/O,直接 I/O 和内存映射。</p></li></ul><p>字符设备：</p><ul><li>命令包括 get，put。</li><li>可以构造库以提供具有缓冲和编辑功能的按行访问。</li></ul><h3 id="网络设备" tabindex="-1">网络设备 <a class="header-anchor" href="#网络设备" aria-label="Permalink to &quot;网络设备&quot;">​</a></h3><p>比如 Socket 接口。</p><h3 id="时钟与定时器" tabindex="-1">时钟与定时器 <a class="header-anchor" href="#时钟与定时器" aria-label="Permalink to &quot;时钟与定时器&quot;">​</a></h3><ul><li>可以获取当前时间，逝去的时间。</li><li>可以设置定时器，在 T 是触发操作 X。</li><li>测量逝去时间和触发操作的硬件称为可编程间隔定时器，它可被设置为等待一定时间，然后触发中断。</li></ul><h3 id="阻塞与非阻塞-i-o" tabindex="-1">阻塞与非阻塞 I/O <a class="header-anchor" href="#阻塞与非阻塞-i-o" aria-label="Permalink to &quot;阻塞与非阻塞 I/O&quot;">​</a></h3><p>阻塞 IO: 指的是需要内核 IO 操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。传统的 IO 模型都是同步阻塞 IO。在 Java 中，默认创建的 socket 都是阻塞的。</p><p>非阻塞 IO：指的是用户空间的程序不需要等待内核 IO 操作彻底完成，可以立即返回用户空间执行用户操作，即处于非阻塞的状态，与此同时内核会立即返回给用户一个状态值。</p><p>简单来说：阻塞是指用户空间（调用线程）一直在等待，而不能干别的事情；非阻塞是指用户空间（调用线程）拿到内核返回的状态值就返回自己的空间，IO 操作可以干就干，不可以干就去干别的事情。</p><h2 id="kernel-i-o-subsystem" tabindex="-1">Kernel I/O Subsystem <a class="header-anchor" href="#kernel-i-o-subsystem" aria-label="Permalink to &quot;Kernel I/O Subsystem&quot;">​</a></h2><h3 id="i-o-调度" tabindex="-1">I/O 调度 <a class="header-anchor" href="#i-o-调度" aria-label="Permalink to &quot;I/O 调度&quot;">​</a></h3><p>调度一组 I/O 就是确定一个合适的顺序来执行这些请求。应用程勋发布的系统调用顺序不一定总是最佳选择，调度能改善系统整体性能，如磁盘调度，重新安排服务顺序增加性能就是 I/O 调度的核心。</p><p>操作系统开发人员通过为每个设备维护一个请求队列来实现调度。</p><h3 id="缓冲" tabindex="-1">缓冲 <a class="header-anchor" href="#缓冲" aria-label="Permalink to &quot;缓冲&quot;">​</a></h3><p>缓冲区是用来保存两个设备之间或在设备和应用程序之间所传输数据的内存区域。使用缓冲的优点：</p><ul><li>处理数据流中生产者与消费者之间的速度差异。使用双缓冲机制，一个缓冲接收生产者数据，另一个缓冲写给消费者，若生产者比较慢，那么当第一个缓冲写满了以后两个缓冲调换，完成了生产者与消费者的分离解耦。</li><li>协调传输数据大小不一致的设备。如网络传输中发送端将大消息分成若干网络包，接收端将它们放在重组缓冲区内。</li><li>支持应用程序 I/0 的复制语义。当用作 buffer 的页面被修改后，复制出一个新的页面，原来的页面用于 write()，新的页面用于修改。</li></ul><h3 id="高速缓存" tabindex="-1">高速缓存 <a class="header-anchor" href="#高速缓存" aria-label="Permalink to &quot;高速缓存&quot;">​</a></h3><p>高速缓存是可以保留数据副本的高速存储器。</p><p>缓冲与高速缓存差别：缓冲可能是数据项的唯一副本；高速缓存只是提供了一个驻留在其他地方的数据在高速存储器上的一个副本。</p><h3 id="假脱机" tabindex="-1">假脱机 <a class="header-anchor" href="#假脱机" aria-label="Permalink to &quot;假脱机&quot;">​</a></h3><p>目的： 解决独占设备的并发访问问题以提高设备利用率。</p><p>假脱机是用来保存设备输出的缓冲区，这些设备不能接收交叉的数据流。比如，应用程序的输出先是假脱机到一个独立的磁盘文件上，当应用程序完成打印时，假脱机系统将对应的待送打印机的脱机文件进行排队。</p><h2 id="transforming-i-o-requests-to-hardware-operations" tabindex="-1">Transforming I/O Requests to Hardware Operations <a class="header-anchor" href="#transforming-i-o-requests-to-hardware-operations" aria-label="Permalink to &quot;Transforming I/O Requests to Hardware Operations&quot;">​</a></h2><p>Consider reading a file from disk for a process:</p><ul><li>Determine device holding file 确定设备保持文件</li><li>Translate name to device representation 将名称转换为设备表示</li><li>Physically read data from disk into buffer</li><li>Make data available to requesting process</li><li>Return control to process</li></ul><h3 id="life-cycle-of-an-i-o-request" tabindex="-1">Life Cycle of An I/O Request <a class="header-anchor" href="#life-cycle-of-an-i-o-request" aria-label="Permalink to &quot;Life Cycle of An I/O Request&quot;">​</a></h3><h2 id="streams" tabindex="-1">STREAMS <a class="header-anchor" href="#streams" aria-label="Permalink to &quot;STREAMS&quot;">​</a></h2><h2 id="performance" tabindex="-1">Performance <a class="header-anchor" href="#performance" aria-label="Permalink to &quot;Performance&quot;">​</a></h2>',62),s=[o];function n(p,h,c,d,u,f){return e(),i("div",null,s)}const O=a(t,[["render",n]]);export{b as __pageData,O as default};
