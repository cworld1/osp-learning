import{_ as e,o as t,c as i,R as r}from"./chunks/framework.GAJuE5ww.js";const s="/osp-learning/assets/image_FSdwjEBJ8h.1e7atvZ_.png",a="/osp-learning/assets/image_kxXf7QR9jF.41Xk90WU.png",o="/osp-learning/assets/image_LrLA1afNsj.NwQB-5zZ.png",n="/osp-learning/assets/image_s9gBipIr_y.YIqmZfJ3.png",S=JSON.parse('{"title":"02 Operating-System Structures","description":"","frontmatter":{},"headers":[],"relativePath":"02-os-structures.md","filePath":"02-os-structures.md","lastUpdated":1729693534000}'),l={name:"02-os-structures.md"},m=r('<h1 id="_02-operating-system-structures" tabindex="-1">02 Operating-System Structures <a class="header-anchor" href="#_02-operating-system-structures" aria-label="Permalink to &quot;02 Operating-System Structures&quot;">​</a></h1><h2 id="contents" tabindex="-1">Contents <a class="header-anchor" href="#contents" aria-label="Permalink to &quot;Contents&quot;">​</a></h2><ul><li>Operating System Services</li><li>User Operating System Interface</li><li>System Calls</li><li>Types of System Calls</li><li>System Programs</li><li>Operating System Design and Implementation</li><li>Operating System Structure</li><li>Operating System Debugging</li><li>Operating System Generation</li><li>System Boot</li></ul><h3 id="objectives" tabindex="-1">Objectives <a class="header-anchor" href="#objectives" aria-label="Permalink to &quot;Objectives&quot;">​</a></h3><ul><li>描述操作系统为用户、进程和其他系统提供的服务</li><li>讨论构建操作系统的各种方法</li><li>解释如何安装和定制操作系统，以及如何启动操作系统</li></ul><h2 id="operating-system-services" tabindex="-1">Operating System Services <a class="header-anchor" href="#operating-system-services" aria-label="Permalink to &quot;Operating System Services&quot;">​</a></h2><p>Operating systems provide an environment for execution of programs and services to programs and users 操作系统为程序和用户提供执行程序和服务的环境</p><p>One set of operating-system services provides functions that are helpful to the user: 一组操作系统服务提供了对用户有帮助的功能：</p><ul><li><strong>User interface</strong> - Almost all operating systems have a user interface (<strong>UI</strong>). Varies between <strong>Command-Line (CLI)</strong>, <strong>Graphics User Interface (GUI)</strong>, <strong>Batch.</strong> 几乎所有操作系统都有用户界面（<strong>UI</strong>）。在<strong>命令行（CLI）</strong>、<strong>图形用户界面（GUI）</strong>、<strong>批处理</strong>之间变化。</li><li><strong>Program execution 程序执行</strong> - The system must be able to load a program into memory and to run that program, end execution, either normally or abnormally (indicating error). 系统必须能够将程序加载到内存中，并正常或异常（显示错误）运行程序，结束执行。</li><li><strong>I/O operations</strong> - A running program may require I/O, which may involve a file or an I/O device.</li><li><strong>File-system manipulation 文件系统操作</strong> - The file system is of particular interest. Programs need to read and write files and directories, create and delete them, search them, list file Information, permission management. 文件系统特别重要。程序需要读取和写入文件和目录、创建和删除它们、搜索它们、列出文件信息和权限管理。</li><li><strong>Communications 通信</strong> - Processes may exchange information, on the same computer or between computers over a network. 进程可以在同一台计算机上或通过网络在计算机之间交换信息。通信可以通过共享内存或通过操作系统传递消息（数据包）进行。</li><li><strong>Error detection 错误检测</strong> - OS needs to be constantly aware of possible errors. 操作系统需要不断地注意可能存在的错误。 <ul><li>错误可能出现在 CPU 和内存硬件、I/O 设备、用户程序中。</li><li>对于每种类型的错误，操作系统都应采取适当的措施，以确保正确和一致的计算。</li><li>调试工具可以极大地增强用户和程序员使用系统的能力。</li></ul></li></ul><p><strong>A View of Operating System Services：</strong></p><p><img src="'+s+'" alt=""></p><h2 id="user-operating-system-interface" tabindex="-1"><strong>User Operating System Interface</strong> <a class="header-anchor" href="#user-operating-system-interface" aria-label="Permalink to &quot;**User Operating System Interface**&quot;">​</a></h2><ul><li>CLI or <strong>command interpreter</strong> allows direct command entry.</li><li>GUI bring ser-friendly <strong>desktop</strong> metaphor interface.</li></ul><p>Many systems now include both CLI and GUI interfaces.</p><h2 id="system-calls" tabindex="-1">System Calls <a class="header-anchor" href="#system-calls" aria-label="Permalink to &quot;System Calls&quot;">​</a></h2><ul><li>Programming interface to the services provided by the OS 操作系统提供的服务的编程接口</li><li>Typically written in a high-level language (C or C++) 通常用高级语言（如 C 或 C++）编写</li><li>Mostly accessed by programs via a high-level <strong>Application Programming Interface (API)</strong> rather than direct system call use 大多数情况下，程序通过高级 <strong>应用程序编程接口（API）</strong> 访问，而不是直接使用系统调用</li><li>Three most common APIs are Win32 API for Windows, POSIX API for POSIX-based systems (including virtually all versions of UNIX, Linux, and Mac OS X), and Java API for the Java virtual machine (JVM) 三个最常见的 API 是 Windows 的 Win32 API，基于 POSIX 的系统的 POSIX API（包括几乎所有版本的 UNIX、Linux 和 Mac OS X），以及 Java 虚拟机（JVM）的 Java API</li></ul><h3 id="system-call-parameter-passing" tabindex="-1">System Call Parameter Passing <a class="header-anchor" href="#system-call-parameter-passing" aria-label="Permalink to &quot;System Call Parameter Passing&quot;">​</a></h3><p>向操作系统传递参数的三种一般方法：</p><ul><li>最简单：在寄存器中传递参数 在某些情况下，参数可能比寄存器还多</li><li>参数存储在内存中的块或表中，块的地址作为寄存器中的参数传递（Linux 和 Solaris 采用这种方法）</li><li>参数由程序放置或推入堆栈，由操作系统从堆栈中弹出</li><li>块和堆栈方法不限制传递参数的数量或长度</li></ul><h2 id="types-of-system-calls" tabindex="-1">Types of System Calls <a class="header-anchor" href="#types-of-system-calls" aria-label="Permalink to &quot;Types of System Calls&quot;">​</a></h2><p>Process control 过程控制:</p><ul><li>create process, terminate process</li><li>end, abort</li><li>load, execute</li><li>get process attributes, set process attributes</li><li>wait for time</li><li>wait event, signal event</li><li>allocate and free memory</li><li>Dump memory if error</li><li><strong>Debugger</strong> for determining <strong>bugs, single step</strong> execution</li><li><strong>Locks</strong> for managing access to shared data between processes</li></ul><p>File management 文件管理:</p><ul><li>create file, delete file</li><li>open, close file</li><li>read, write, reposition</li><li>get and set file attributes</li></ul><p>Device management 设备管理:</p><ul><li>request device, release device</li><li>read, write, reposition</li><li>get device attributes, set device attributes</li><li>logically attach or detach devices</li></ul><p>Information maintenance 信息维护:</p><ul><li>get time or date, set time or date</li><li>get system data, set system data</li><li>get and set process, file, or device attributes</li></ul><p>Communications 通信:</p><ul><li>create, delete communication connection</li><li>send, receive messages if message passing model to host name or process name</li><li>from client to server</li><li>shared-memory model create and gain access to memory regions</li><li>transfer status information</li><li>attach and detach remote devices</li></ul><p>Protection 防护:</p><ul><li>Control access to resources</li><li>Get and set permissions</li><li>Allow and deny user access</li></ul><h2 id="system-programs" tabindex="-1">System Programs <a class="header-anchor" href="#system-programs" aria-label="Permalink to &quot;System Programs&quot;">​</a></h2><p>System programs provide a convenient environment for program development and execution. They can be divided into:</p><ul><li>File manipulation (文件操作)</li><li>Status information sometimes stored in a file modification (状态信息有时存储在文件修改中)</li><li>Programming language support (编程语言支持)</li><li>Program loading and execution (程序加载和执行)</li><li>Communications (通信)</li><li>Background services (后台服务)</li><li>Application programs (应用程序)</li></ul><p>Most users&#39; interaction with the operating system is through system programs rather than actual system calls.</p><h2 id="operating-system-structure" tabindex="-1">Operating System Structure <a class="header-anchor" href="#operating-system-structure" aria-label="Permalink to &quot;Operating System Structure&quot;">​</a></h2><h3 id="simple-structure-—-ms-dos" tabindex="-1">Simple Structure — MS-DOS <a class="header-anchor" href="#simple-structure-—-ms-dos" aria-label="Permalink to &quot;Simple Structure — MS-DOS&quot;">​</a></h3><p>MS-DOS – written to provide the most functionality in the least space. 旨在以最小的空间提供最多的功能。</p><ul><li>Not divided into modules</li><li>Although MS-DOS has some structure, its interfaces and levels of functionality are not well separated.</li></ul><p><img src="'+a+'" alt=""></p><h3 id="non-simple-structure-—-unix" tabindex="-1">Non Simple Structure — UNIX <a class="header-anchor" href="#non-simple-structure-—-unix" aria-label="Permalink to &quot;Non Simple Structure — UNIX&quot;">​</a></h3><p>UNIX – limited by hardware functionality, the original UNIX operating system had limited structuring. 由于硬件功能的限制，最初的 UNIX 操作系统的结构有限。</p><p>The UNIX OS consists of two separable parts:</p><ul><li>Systems programs</li><li>The kernel</li></ul><p>The kernel is consisting of everything below the system-call interface and above the physical hardware. And it provides the file system, CPU scheduling, memory management, and other operating-system functions; a large number of functions for one level. 内核由系统调用接口以下和物理硬件之上的所有内容组成。 并提供文件系统、CPU 调度、内存管理等操作系统功能； 一个级别有大量功能。</p><h3 id="traditional-unix-system-structure" tabindex="-1">Traditional UNIX System Structure <a class="header-anchor" href="#traditional-unix-system-structure" aria-label="Permalink to &quot;Traditional UNIX System Structure&quot;">​</a></h3><p>Beyond simple but not fully layered:</p><p><img src="'+o+'" alt=""></p><h3 id="microkernel-system-structure" tabindex="-1">Microkernel System Structure <a class="header-anchor" href="#microkernel-system-structure" aria-label="Permalink to &quot;Microkernel System Structure&quot;">​</a></h3><ul><li>Moves as much from the kernel into user space. 从内核转为用户空间</li><li>Mach example of microkernel. <blockquote><p>Mac OS X kernel (Darwin) partly based on Mach.</p></blockquote></li><li>Communication takes place between user modules using message passing. 用户与模块之间使用消息传递进行通信。</li></ul><p>Benefits:</p><ul><li>Easier to extend a microkernel.</li><li>Easier to port the operating system to new architectures. 更容易将操作系统移植到新体系结构。</li><li>More reliable (less code is running in kernel mode).</li><li>More secure.</li></ul><p>Detriments 缺点:</p><ul><li>Performance overhead of user space to kernel space communication. 用户空间到内核空间通信的性能开销。</li></ul><p><img src="'+n+'" alt=""></p><h3 id="hybrid-systems" tabindex="-1">Hybrid Systems <a class="header-anchor" href="#hybrid-systems" aria-label="Permalink to &quot;Hybrid Systems&quot;">​</a></h3><p>Most modern operating systems are actually not one pure model</p><h2 id="operating-system-debugging" tabindex="-1">Operating-System Debugging <a class="header-anchor" href="#operating-system-debugging" aria-label="Permalink to &quot;Operating-System Debugging&quot;">​</a></h2><ul><li>Debugging is finding and fixing errors, or bugs.</li><li>OS generates log files 日志文件 containing error information.</li><li>Failure of an application can generate a core dump file capturing the memory of the process. 应用程序失败会生成一个捕获进程内存的核心转储文件。</li><li>Operating system failure can generate a crash dump file containing kernel memory 包含内核内存的故障转储文件.</li><li>Beyond crashes, performance tuning can optimize system performance. <ul><li>Sometimes using trace listings of activities, recorded for analysis. 有时使用记录的活动跟踪列表以供分析。</li><li>Profiling is periodic sampling of the instruction pointer to look for statistical trends. 分析是对指令指针进行定期采样以查找统计趋势。</li></ul></li></ul><blockquote><p><strong>DTrace</strong></p><p>tool in Solaris, FreeBSD, Mac OS X allows live instrumentation on production systems.</p><p>Probes fire when code is executed within a provider, capturing state data and sending it to consumers of those probes. 当代码在提供者中执行时，探针会触发，捕获状态数据并将其发送给这些探针的使用者。</p></blockquote><h2 id="operating-system-generation" tabindex="-1">Operating System Generation <a class="header-anchor" href="#operating-system-generation" aria-label="Permalink to &quot;Operating System Generation&quot;">​</a></h2><p>Operating systems are designed to run on any of a class of machines; the system must be configured for each specific computer site. 操作系统被设计成在任何一类机器上运行；必须为每个特定计算机站点配置系统。</p><h3 id="system-boot" tabindex="-1">System Boot <a class="header-anchor" href="#system-boot" aria-label="Permalink to &quot;System Boot&quot;">​</a></h3><ul><li>When power is initialized on the system, execution starts at a fixed memory location 从一个固定的内存位置开始执行代码.</li><li>Firmware 固件 ROM is used to hold the initial boot code.</li><li>The operating system must be made available to hardware 必须可供硬件使用 so that the hardware can start it.</li><li>A small piece of code, called a bootstrap loader, is stored in ROM or EEPROM. It locates the kernel 定位内核, loads it into memory, and starts it.</li><li>Sometimes it is a two-step process where a boot block at a fixed location is loaded by ROM code, which then loads the bootstrap loader from the disk 其中固定位置的引导块由 ROM 代码加载，然后从磁盘加载引导加载程序.</li><li>A common bootstrap loader 常见的引导加载程序, GRUB, allows the selection of a kernel from multiple disks, versions, and kernel options.</li><li>The kernel loads, and the system is then running.</li></ul>',65),c=[m];function u(p,d,g,h,y,f){return t(),i("div",null,c)}const v=e(l,[["render",u]]);export{S as __pageData,v as default};
