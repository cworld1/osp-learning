import{_ as l,o as i,c as a,R as e}from"./chunks/framework.GAJuE5ww.js";const h=JSON.parse('{"title":"Mid Exam","description":"","frontmatter":{},"headers":[],"relativePath":"ex-mid-exam.md","filePath":"ex-mid-exam.md","lastUpdated":1729693534000}'),t={name:"ex-mid-exam.md"},p=e('<h1 id="mid-exam" tabindex="-1">Mid Exam <a class="header-anchor" href="#mid-exam" aria-label="Permalink to &quot;Mid Exam&quot;">​</a></h1><h2 id="多道程序设计" tabindex="-1">多道程序设计 <a class="header-anchor" href="#多道程序设计" aria-label="Permalink to &quot;多道程序设计&quot;">​</a></h2><ul><li>允许程序并发执行</li><li>以前不会有虚拟存储的管理，后来有。</li><li>能够实现共享资源的管理（还会因此产生同步、互斥、死锁）</li><li>理论上说进程越多，CPU 利用率越高（但是死锁会影响）</li></ul><h2 id="用户态与内核态执行" tabindex="-1">用户态与内核态执行 <a class="header-anchor" href="#用户态与内核态执行" aria-label="Permalink to &quot;用户态与内核态执行&quot;">​</a></h2><ul><li>命令解释程序：把命令以系统能够理解的方式执行（用户态）</li><li>中断（内核态）</li><li>进程调度（内核态）</li><li>时钟中断（内核态）</li><li>用户态不能执行特权指令</li></ul><p>进程启动</p><ul><li>引导程序处于 ROM 当中，启动会自检</li><li>不会全部加载系统资源到内存，在需要的时候才会调用</li><li>启动时也会产生交互</li></ul><p>进程：</p><ul><li>内存不够的时候会被 swap out 到磁盘上</li></ul><p>关于系统：</p><ul><li>不一定提供方 GUI</li><li>为进程提供系统调用命令</li><li>操作系统都需要中断进行处理</li></ul><p>处理器执行：特权指令、用户指令</p><ul><li>不允许直接操作特权指令</li><li>操作系统执行特权指令</li></ul><p>cpu 执行 os 代码，处理器处于：内核态</p><p>执行系统调用的过程：</p><ul><li>CPU 负责保存断点（就是 PC 指针指向的地址，方便继续执行）和程序状态字（计算机线性状态）</li><li>操作系统负责保存通用寄存器的内容（用户态转换为内核态）</li><li>操作系统执行系统调用 routine</li><li>CPU 负责用户态和内核态切换</li><li>操作系统负责提供中断服务（如 init 等函数）、中断向量表（提供中断处理程序的记录）</li><li>操作系统保存中断的屏蔽字（指按照优先级处理中断）</li></ul><p>进程在内核下有 PCB。</p><p>一个进程的状态变化可能会引起另一个进程状态的变化（new 到 ready、waiting/blocked 阻塞到 ready 就不会）</p><p>线程与进程</p><ul><li>线程是比进程更小的单位，但不能独立运行</li><li>线程能够提高程序的并发性，提高效率</li></ul><p>两个合作的进程：</p><ul><li>通过文件共享</li><li>通过内存共享</li><li>通过消息传递共享</li><li>不能通过全局变量</li></ul><p>执行态变柱塞：</p><ul><li>读取文件：阻塞</li><li>进程执行完成：就绪</li><li>申请外设：阻塞</li><li>进程执行信号量：排队阻塞</li></ul><p>旅行社订飞机票，什么属于互斥资源：飞机票，也就是系统的 counter。</p><p>初始值 3，当前 1：1 资源可用，0 等待</p><h2 id="内核态、用户态" tabindex="-1">内核态、用户态 <a class="header-anchor" href="#内核态、用户态" aria-label="Permalink to &quot;内核态、用户态&quot;">​</a></h2><p>区分内核态、用户态：保护程序。</p><p>内核态、用户态什么时候切换：中断和中断返回。</p><p>为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？</p><ol><li>终端型用户。由于终端型用户提交的作业多属于交互性作业，通常较小，系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意。</li><li>短批处理作业用户。对于这类作业，如果可在第一队列中执行完成，便可获得与终端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。</li><li>长批处理作业用户。对于长作业，它将依次在第 1，2，…，n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</li></ol>',31),o=[p];function r(d,u,n,s,c,m){return i(),a("div",null,o)}const x=l(t,[["render",r]]);export{h as __pageData,x as default};
